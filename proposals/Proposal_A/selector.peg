start
  = "$" operators:operators { return operators; }

operators
  = operators:operator* { return operators.reduce((os, o) => [...os, ...o], []); }

operator
  = dotNotation
  / union
  / recursiveDescentWithChildren


dotNotation
  = "." children:dotNotationIdentifier { return children; }

dotNotationIdentifier
  = scalarDotNotationIdentifier
  / listDotNotationIdentifier

scalarDotNotationIdentifier
  = [^\.\*\[\]\(\)@\?\|& ,:=<>!"'\\]+ { return [['children', [['name', text()]]]]; }

listDotNotationIdentifier
  = "*" { return [['children', [['all']]]]; }


union
  = "[" ws children:bracketElements ws "]" { return [['children', children]]; }

bracketElements
  = x:bracketElement ws "," ws xs:bracketElements { return [x, ...xs]; }
  / x:bracketElement { return [x]; }

bracketElement
  = listBracketElement
  / scalarBracketElement

scalarBracketElement
  = "'" name:singleQuotedString "'" { return ['name', name]; }
  / '"' name:doubleQuotedString '"' { return ['name', name]; }
  / index:integer { return ['index', index]; }

listBracketElement
  = "*" { return ['all']; }
  / start:integer? ":" end:integer? ":" step:nonZeroInteger? { return ['slice', start, end, step]; }
  / start:integer? ":" end:integer? { return ['slice', start, end, null]; }
  / "?(" filterExpression:filterExpression ")" { return ['filter', filterExpression]; }

singleQuotedString
  = x:"\\'" xs:singleQuotedString { return "'" + xs; }
  / x:"\\\\" xs:singleQuotedString { return "\\" + xs; }
  / x:[^'] xs:singleQuotedString { return x + xs; }
  / ''

doubleQuotedString
  = x:'\\"' xs:doubleQuotedString { return '"' + xs; }
  / x:'\\\\' xs:doubleQuotedString { return "\\" + xs; }
  / x:[^"] xs:doubleQuotedString { return x + xs; }
  / ''

integer
  = "-"? ( "0" / ([1-9] [0-9]*) ) { return parseInt(text(), 10); }

nonZeroInteger
  = "-"? [1-9] [0-9]* { return parseInt(text(), 10); }


filterExpression
  = x:higherPrecedenceFilterExpression ws "&&" ws xs:logicalAndRightHandSide { return ["and", ["expression", x], ...xs]; }
  / x:higherPrecedenceFilterExpression ws "||" ws xs:logicalOrRightHandSide { return ["or", ["expression", x], ...xs]; }
  / higherPrecedenceFilterExpression

higherPrecedenceFilterExpression
  = left:filterValue ws op:comparisonOperator ws right:filterValue { return [op, ["value", left], ["value", right]]; }
  / unaryFilterExpression

logicalAndRightHandSide
  = x:higherPrecedenceFilterExpression ws "&&" ws xs:logicalAndRightHandSide { return [["expression", x], ...xs]; }
  / expression:higherPrecedenceFilterExpression { return [["expression", expression]]; }

logicalOrRightHandSide
  = x:higherPrecedenceFilterExpression ws "||" ws xs:logicalOrRightHandSide { return [["expression", x], ...xs]; }
  / expression:higherPrecedenceFilterExpression { return [["expression", expression]]; }

unaryFilterExpression
  = value:filterValue { return ["hasValue", ["value", value]]; }
  / "!" ws expression:unaryFilterExpression { return ["not", ["expression", expression]]; }
  / "(" ws expression:filterExpression ws ")" { return expression; }

comparisonOperator
  = "==" { return "equals"; }
  / "!=" { return "notEquals"; }
  / "<=" { return "lessThanOrEqual"; }
  / ">=" { return "greaterThanOrEqual"; }
  / "<" { return "lessThan"; }
  / ">" { return "greaterThan"; }

filterValue
  = "@" operators:scalarOperators { return ["current", operators]; }
  / "$" operators:scalarOperators { return ["root", operators]; }
  / constant:simpleValue { return ["constant", constant]; }

scalarOperators
  = operators:scalarOperator* { return operators.reduce((os, o) => [...os, ...o], []); }

scalarOperator
  = scalarDotNotation
  / scalarBracketNotation

scalarDotNotation
  = "." children:scalarDotNotationIdentifier { return children; }

scalarBracketNotation
  = "[" ws child:scalarBracketElement ws "]" { return [['children', [child]]]; }

simpleValue
  = "'" string:singleQuotedString "'" { return string; }
  / '"' string:doubleQuotedString '"' { return string; }
  / "false" { return false; }
  / "true" { return true; }
  / "null" { return null; }
  / number

number
  = "-"? integerPart fraction? exponent? { return parseFloat(text()); }

exponent
  = [eE] ("-" / "+")? [0-9]+

fraction
  = "." [0-9]+

integerPart
  = "0" / ([1-9] [0-9]*)


ws
  = " "*


recursiveDescentWithChildren
  = ".." children:dotNotationIdentifier { return [['recursiveDescent'], ...children]; }
  / ".." children:union { return [['recursiveDescent'], ...children]; }
