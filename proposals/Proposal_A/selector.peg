Start
  = "$" operators:Operator* { return operators.reduce((os, o) => [...os, ...o], []); }

Operator
  = DotChild
  / BracketChild
  / RecursiveDescentWithChildren

DotChild
  = "." childName:DotChildName { return [['children', [['name', childName]]]]; }
  / ".*" { return [['children', [['all']]]]; }

DotChildName
  = [^\.\*\[\]\(\)@\?\|& ,:=<>!"'\\]+ { return text(); }

BracketChild
  = "[" ws children:BracketElements ws "]" { return [['children', children]]; }

BracketElements
  = x:BracketElement ws "," ws xs:BracketElements { return [x, ...xs]; }
  / x:BracketElement { return [x]; }

BracketElement
  = ListBracketElement
  / ScalarBracketElement

ScalarBracketElement
  = "'" name:SingleQuotedString "'" { return ['name', name]; }
  / '"' name:DoubleQuotedString '"' { return ['name', name]; }
  / index:Integer { return ['index', index]; }

ListBracketElement
  = "*" { return ['all']; }
  / start:Integer? ":" end:Integer? ":" step:NonZeroInteger? { return ['slice', start, end, step]; }
  / start:Integer? ":" end:Integer? { return ['slice', start, end, null]; }
  / "?(" filterExpression:FilterExpression ")" { return ['filter', filterExpression]; }

RecursiveDescentWithChildren
  = ".." childName:DotChildName { return [['recursiveDescent'], ['children', [['name', childName]]]]; }
  / "..*" { return [['recursiveDescent'], ['children', [['all']]]]; }
  / ".." children:BracketChild { return [['recursiveDescent'], ...children]; }

FilterExpression
  = x:HigherPrecedenceFilterExpression ws "&&" ws xs:LogicalAndRightHandSide { return ["and", ["expression", x], ...xs]; }
  / x:HigherPrecedenceFilterExpression ws "||" ws xs:LogicalOrRightHandSide { return ["or", ["expression", x], ...xs]; }
  / HigherPrecedenceFilterExpression

HigherPrecedenceFilterExpression
  = left:FilterValue ws op:ComparisonOperator ws right:FilterValue { return [op, ["value", left], ["value", right]]; }
  / UnaryFilterExpression

LogicalAndRightHandSide
  = x:HigherPrecedenceFilterExpression ws "&&" ws xs:LogicalAndRightHandSide { return [["expression", x], ...xs]; }
  / expression:HigherPrecedenceFilterExpression { return [["expression", expression]]; }

LogicalOrRightHandSide
  = x:HigherPrecedenceFilterExpression ws "||" ws xs:LogicalOrRightHandSide { return [["expression", x], ...xs]; }
  / expression:HigherPrecedenceFilterExpression { return [["expression", expression]]; }

UnaryFilterExpression
  = value:FilterValue { return ["hasValue", ["value", value]]; }
  / "!" ws expression:UnaryFilterExpression { return ["not", ["expression", expression]]; }
  / "(" ws expression:FilterExpression ws ")" { return expression; }

ComparisonOperator
  = "==" { return "equals"; }
  / "!=" { return "notEquals"; }
  / "<=" { return "lessThanOrEqual"; }
  / ">=" { return "greaterThanOrEqual"; }
  / "<" { return "lessThan"; }
  / ">" { return "greaterThan"; }

FilterValue
  = "@" operators:ScalarOperators { return ["current", operators]; }
  / "$" operators:ScalarOperators { return ["root", operators]; }
  / constant:SimpleValue { return ["constant", constant]; }

ScalarOperators
  = operators:ScalarOperator* { return operators.reduce((os, o) => [...os, ...o], []); }

ScalarOperator
  = ScalarDotNotation
  / ScalarBracketNotation

ScalarDotNotation
  = "." childName:DotChildName { return [['children', [['name', childName]]]]; }

ScalarBracketNotation
  = "[" ws child:ScalarBracketElement ws "]" { return [['children', [child]]]; }

SimpleValue
  = "'" string:SingleQuotedString "'" { return string; }
  / '"' string:DoubleQuotedString '"' { return string; }
  / "false" { return false; }
  / "true" { return true; }
  / "null" { return null; }
  / Number

SingleQuotedString
  = x:"\\'" xs:SingleQuotedString { return "'" + xs; }
  / x:"\\\\" xs:SingleQuotedString { return "\\" + xs; }
  / x:[^'] xs:SingleQuotedString { return x + xs; }
  / ''

DoubleQuotedString
  = x:'\\"' xs:DoubleQuotedString { return '"' + xs; }
  / x:'\\\\' xs:DoubleQuotedString { return "\\" + xs; }
  / x:[^"] xs:DoubleQuotedString { return x + xs; }
  / ''

Integer
  = "-"? ( "0" / ([1-9] [0-9]*) ) { return parseInt(text(), 10); }

NonZeroInteger
  = "-"? [1-9] [0-9]* { return parseInt(text(), 10); }

Number
  = "-"? IntegerPart Fraction? Exponent? { return parseFloat(text()); }

Exponent
  = [eE] ("-" / "+")? [0-9]+

Fraction
  = "." [0-9]+

IntegerPart
  = "0" / ([1-9] [0-9]*)

ws
  = " "*
