start
  = "$" operators:operators { return operators; }

operators
  = operators:operator* { return operators.reduce((os, o) => os.concat(o), []); }

operator
  = dotNotation
  / union
  / recursiveDescentWithChildren


dotNotation
  = "." children:dotNotationIdentifier { return children; }

dotNotationIdentifier
  = scalarDotNotationIdentifier
  / listDotNotationIdentifier

scalarDotNotationIdentifier
  = [^\.\*\[\]\(\)@\?\|& ,:=<>!"'\\]+ { return [['children', [['name', text()]]]]; }

listDotNotationIdentifier
  = "*" { return [['children', [['all']]]]; }


union
  = "[" whitespace children:bracketElements whitespace "]" { return [['children', children]]; }

bracketElements
  = x:bracketElement whitespace "," whitespace xs:bracketElements { return [x].concat(xs); }
  / x:bracketElement { return [x]; }

bracketElement
  = listBracketElement
  / scalarBracketElement

scalarBracketElement
  = "'" name:singleQuotedString "'" { return ['name', name]; }
  / '"' name:doubleQuotedString '"' { return ['name', name]; }
  / index:number { return ['index', index]; }

listBracketElement
  = "*" { return ['all']; }
  / start:number? ":" end:number? ":" step:nonZeroNumber? { return ['slice', start, end, step]; }
  / start:number? ":" end:number? { return ['slice', start, end, null]; }
  / "?(" filterExpression:filterExpression ")" { return ['filter', filterExpression]; }

singleQuotedString
  = x:"\\'" xs:singleQuotedString { return "'" + xs; }
  / x:"\\\\" xs:singleQuotedString { return "\\" + xs; }
  / x:[^'] xs:singleQuotedString { return x + xs; }
  / ''

doubleQuotedString
  = x:'\\"' xs:doubleQuotedString { return '"' + xs; }
  / x:'\\\\' xs:doubleQuotedString { return "\\" + xs; }
  / x:[^"] xs:doubleQuotedString { return x + xs; }
  / ''

number
  = "-"? absoluteNumberText { return parseInt(text(), 10); }

nonZeroNumber
  = "-"? [1-9] absoluteNumberText? { return parseInt(text(), 10); }

absoluteNumberText
  = [0-9]+ { return text(); }


filterExpression
  = left:filterPartial whitespace op:binaryOperator whitespace right:filterPartial { return [op, left, right]; }
  / partial:filterPartial { return ["hasValue", partial]; }

binaryOperator
  = "==" { return "equals"; }
  / "!=" { return "notEquals"; }
  / "<=" { return "lessThanOrEqual"; }
  / ">=" { return "greaterThanOrEqual"; }
  / "<" { return "lessThan"; }
  / ">" { return "greaterThan"; }

filterPartial
  = "@" operators:scalarOperators { return ["current", operators]; }
  / "$" operators:scalarOperators { return ["root", operators]; }
  / constant:jsonValue { return ["constant", constant]; }

scalarOperators
  = operators:scalarOperator* { return operators.reduce((os, o) => os.concat(o), []); }

scalarOperator
  = scalarDotNotation
  / scalarBracketNotation

scalarDotNotation
  = "." children:scalarDotNotationIdentifier { return children; }

scalarBracketNotation
  = "[" whitespace child:scalarBracketElement whitespace "]" { return [['children', [child]]]; }

// TODO need full JSON spec here + exemption for single quoted strings
jsonValue
  = "null" { return null; }
  / "true" { return true; }
  / "false" { return false; }
  / number:number { return number; }
  / "'" string:singleQuotedString "'" { return string; }
  / '"' string:doubleQuotedString '"' { return string; }

whitespace
  = " "*


recursiveDescentWithChildren
  = ".." children:dotNotationIdentifier { return [['recursiveDescent']].concat(children); }
  / ".." children:union { return [['recursiveDescent']].concat(children); }
